module
	kind es6
	import { dasherize } from '../utils/helpers'
	+
	$include editor/stylesEditorMetaForm
	$include html/htmlFragments
	$include css/initialCssRules
	+
	class StylesData
		ctor
			_ this.loadStylesEditorMetaForm(stylesEditorMetaForm)
			_ this.loadHtmlFragments(htmlFragments)
			_ this.loadInitialCssRules(initialCssRules)
			_ this.initialize

		m initialize
			# TODO restore from local storage
			_ this.selectHtmlFragment
				@ Object.keys(this.htmlFragments)[0]
			_ this.selectRule
				@ this.selectedHtmlFragmentRuleIds[0]
			_ this.selectStyleGroup
				@ this.styleGroupIds[0]
	
		m loadStylesEditorMetaForm
			param stylesEditorMetaForm
			set this.stylesEditorMetaForm = stylesEditorMetaForm
			set this.styleGroups = {}
			set this.styleGroupIds = []
			foreach g in this.stylesEditorMetaForm.groups
				set this.styleGroups[g.id] = g
				_ this.styleGroupIds.push(g.id)
				foreach control in g.controls
					# log '<<<< control', control
					set control.label = dasherize(control.label || control.id)
					set control.info = createControlInfo(control.id)
		
		m loadHtmlFragments
			param htmlFragments
			
			set this.htmlFragments = htmlFragments
			set this.htmlFragmentsRules = {}
			set this.htmlFragmentStyles = {}
			set this.cssRules = {}
			
			for var fragmentId in htmlFragments
				# log 'loading fragment', fragmentId
				set this.htmlFragmentsRules[fragmentId] = {}
				set this.htmlFragmentStyles[fragmentId] = {}
				const fragment = htmlFragments[fragmentId]
				_ this.analizeFragment(fragment, fragmentId)

			log 'loaded cssRules', this.cssRules
			log 'loaded htmlFragmentsRule', this.htmlFragmentsRules
			log 'loaded htmlFragmentStyles', this.htmlFragmentStyles

		m analizeFragment
			param fragment
			param fragmentId

			# log ' -- fragment', fragment

			if fragment.class
				const xclasses = fragment.class.split(' ')
				foreach xclass in xclasses
					if xclass.length > 0
						# log 'analizeFragment.fragmentId, xclass', fragmentId, xclass
						set this.cssRules[xclass] = {}
						set this.htmlFragmentsRules[fragmentId][xclass] = this.cssRules[xclass]
			
			if fragment.children
				foreach child in fragment.children
					_ this.analizeFragment(child, fragmentId)
		
		m loadInitialCssRules
			param initialCssRules
			
			foreach ruleId in Object.keys(initialCssRules)
				# log '> loadInitialCssRules', ruleId
				if !this.cssRules[ruleId]
					set this.cssRules[ruleId] = {}
				const ruleInitValues = initialCssRules[ruleId]
				const storedValues = this.loadRule(ruleId)
				if !storedValues
					foreach styleId in Object.keys(ruleInitValues)
						# log ' -- ruleId, styleId, value', ruleId, styleId, ruleInitValues[styleId]
						set this.cssRules[ruleId][styleId] = ruleInitValues[styleId]
						_ this.setInitialCssStyle
							@ ruleId
							@ styleId
							@ ruleInitValues[styleId]

			if typeof(localStorage) !== 'undefined'
				foreach ruleId in Object.keys(this.cssRules)
					const storedValues = this.loadRule(ruleId)
					if storedValues
						foreach styleId in Object.keys(storedValues)
							# log ' -- stored ruleId, styleId, value', ruleId, styleId, storedValues[styleId]
							# set this.cssRules[ruleId][styleId] = storedValues[styleId]
							_ this.setInitialCssStyle
								@ ruleId
								@ styleId
								@ storedValues[styleId]


		m setInitialCssStyle
			param ruleId
			param styleId
			param value
			set this.cssRules[ruleId][styleId] = value
			foreach hfId in Object.keys(this.htmlFragmentsRules)
				foreach hfRuleId in Object.keys(this.htmlFragmentsRules[hfId])
					if hfRuleId === ruleId
						set this.htmlFragmentStyles[hfId][styleId] = value

		m selectRule
			param ruleId
			set this.selectedRuleId = ruleId
			_ this.applyRuleToStylesEditorMetaForm(ruleId)

		m selectStyleGroup
			param styleGroupId
			set this.selectedStyleGroupId = styleGroupId
			set this.selectedStyleGroupMetaForm = this.getStylesEditorMetaFormByGroup(this.selectedStyleGroupId)

		m selectHtmlFragment
			param fragmentId
			set this.selectedHtmlFragmentId = fragmentId
			set this.selectedHtmlFragmentRules = this.htmlFragmentsRules[fragmentId]
			set this.selectedHtmlFragmentRuleIds = Object.keys(this.selectedHtmlFragmentRules)
			const ruleId = this.selectedHtmlFragmentRuleIds[0]
			_ this.selectRule
				@ ruleId

		m updateStyles
			param values
			
			const ruleId = this.selectedRuleId

			_ this.storeRule(ruleId, values)

			# log 'StylesData.updateStyles.before', ruleId, this.cssRules[ruleId]
			set this.cssRules[ruleId]
				{
					@ ...this.cssRules[ruleId]
					@ ...values
			# log 'StylesData.updateStyles.after', ruleId, this.cssRules[ruleId]
			
			_ this.applyRuleToStylesEditorMetaForm(ruleId)

		m applyRuleToStylesEditorMetaForm
			param ruleId

			# A rule has been selected
			# The style editor form must be refreshed with the stored values 
			# of the selected rule
			
			const rule = this.cssRules[ruleId]
			log 'cssbuilder.StylesData.applyRuleToStylesEditorMetaForm.ruleId.styles', ruleId, rule
		
			# scan each control of the style editor
			# one control means one style
			foreach g in this.stylesEditorMetaForm.groups
				foreach item in g.controls
					if typeof(rule[item.id]) != "undefined"
						# a value for the style has been stored, set it
						log 'StylesData.applyRuleToStylesEditorMetaForm.ruleId.styleId,value', ruleId, item.id, rule[item.id]
						set item.value = rule[item.id]
					else
						set item.value = undefined

		m getStylesEditorMetaFormByGroup
			param groupId
			return
				_ this.stylesEditorMetaForm.groups.find
					=>
						param group
						return group.id === groupId
		
		m loadRule
			param ruleId
			if typeof(localStorage) !== 'undefined'
				try
					const storedValues = localStorage.getItem("rule_values_" + ruleId)
					return storedValues ? JSON.parse(storedValues) : null
				catch ex
					return null
			else
				return null
		
		m storeRule
			param ruleId
			param values
			if typeof(localStorage) !== 'undefined'
				_ localStorage.setItem("rule_values_" + ruleId, JSON.stringify(values))

	function createControlInfo
		param controlName
		const dashedControlName = dasherize(controlName)
		return
			{
				@ title 'Css style ' + dashedControlName
				@ url '/static/en-US/docs/Web/CSS/' + dashedControlName + '.html#Syntax'
	
	export default StylesData
